"use strict";(self.webpackChunkpetr_leontev_tech_blog=self.webpackChunkpetr_leontev_tech_blog||[]).push([[352],{4603:function(e,t,n){n.r(t),n.d(t,{default:function(){return g}});var a=n(5276),r=n(8453),l=n(6540);function o(e){const t=Object.assign({p:"p",strong:"strong",pre:"pre",code:"code",ol:"ol",li:"li",em:"em",a:"a"},(0,r.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.p,null,"UPD 2023: outlined approach was tested with DirectX 11/12, OpenGL, Vulkan and Metal graphics APIs."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Basics")),"\n",l.createElement(t.p,null,"Once Unreal engine developer starts to think about loading an image at runtime (from disk, network, etc.) it usually leads to the following solution:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-cpp"},"uint32 TextureSizeX = 1024;\nuint32 TextureSizeY = 1024;\nEPixelFormat TextureFormat = PF_B8G8R8A8;\n\n// game thread code\n// create texture\nUTexture2D *Texture = UTexture2D::CreateTransient(TextureSizeX, TextureSizeY, TextureFormat);\n\n// Lock and copies the source data to target\nvoid* TargetTextureData = Texture->PlatformData->Mips[0].BulkData.Lock(LOCK_READ_WRITE);\n{\n\tconst int32 TextureDataSize = CalculateTextureBytes(TextureSizeX, TextureSizeY, TextureFormat);\n\tFMemory::Memcpy(TargetTextureData, SourceTextureData, TextureDataSize);\n}\nTexture->PlatformData->Mips[0].BulkData.Unlock();\n\n// Upload mipmaps data to GPU memory\nTexture->UpdateResource();\n")),"\n",l.createElement(t.p,null,"Can the above code be used? Sure. It is a simple solution, which works well for medium-resolution images. However it is sub-optimal or even bad approach when a set of high resolution images (4k or even 8k) needs to be loaded at runtime without overloading render thread."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Root cause of the render thread hitch")),"\n",l.createElement(t.p,null,'There are few issues that developer probably wants to address before shipping the simple "load image at runtime" code into production:'),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"RHI thread stall (it actually happens on render thread)"),"\n",l.createElement(t.li,null,"Texture and shader resource view (SRV) objects construction"),"\n",l.createElement(t.li,null,"Redundant RHI calls"),"\n"),"\n",l.createElement(t.p,null,"Lets look at each one of them."),"\n",l.createElement(t.p,null,l.createElement(t.em,null,"Texture->UpdateResource();")," leads to so-called synchronous creation of resources in DirectX, which in turn requires to stall RHI thread that is responsible for executing commands via graphics API (i.e. DirectX). The stall here means the current thread has to wait until RHI thread tasks are completed. What happens when there is a heavy scene and user logic should load an image? Right, the render thread hitch."),"\n",l.createElement(t.p,null,"Synchronous texture creation consists of two steps: texture object and corresponding shader resource view (SRV) object construction. If both happen on the render thread then depending on the texture params like a resolution, a number of mip-maps and a pixel format it may take a while."),"\n",l.createElement(t.p,null,"What about redundant RHI calls? First of call, the below code only fills the mipmaps data on CPU side."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-cpp"},"// Lock and copies the source mipmaps data to target buffer:\nvoid* TargetTextureData = Texture->PlatformData->Mips[0].BulkData.Lock(LOCK_READ_WRITE);\n{\n\tconst int32 TextureDataSize = CalculateTextureBytes(TextureSizeX, TextureSizeY, TextureFormat);\n\tFMemory::Memcpy(TargetTextureData, SourceTextureData, TextureDataSize);\n}\nTexture->PlatformData->Mips[0].BulkData.Unlock();\n")),"\n",l.createElement(t.p,null,"How the mipmaps end up uploaded to GPU memory? That is what ",l.createElement(t.em,null,"Texture->UpdateResource();")," does (besides a ton of other things). It creates ",l.createElement(t.em,null,"FTexture2DResource"),", constructs RHI texture via ",l.createElement(t.em,null,"RHICreateTexture2D")," and fills mipmaps one by one using RHI calls like ",l.createElement(t.em,null,"RHILockTexture")," and ",l.createElement(t.em,null,"RHIUnlockTexture")," (these also stall RHI thread, surprise!). Sounds like a lot? Well, there are even more things going on under the hood!"),"\n",l.createElement(t.p,null,"To sump up the cost of calling ",l.createElement(t.em,null,"Texture->UpdateResource()")," is huge! There must be a better approach to load an image at runtime == better approach to construct textures in Unreal Engine."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Asynchronous texture creation")),"\n",l.createElement(t.p,null,"First step is to eliminate as many RHI thread stalls as possible. There is an efficient way to construct RHI texture and SRV. One can use it by calling ",l.createElement(t.em,null,"RHIAsyncCreateTexture2D")," from outside the render thread. It returns ",l.createElement(t.em,null,"FTexture2DRHIRef")," that can later be linked to ",l.createElement(t.em,null,"UTexture2D"),"."),"\n",l.createElement(t.p,null,"Second step requires to create UTexture2D using dummy information. It is as simple as allocating a single 1x1 mipmap on CPU and calling ",l.createElement(t.em,null,"Texture->UpdateResource();"),". In this case it won't take as much time as constructing a texture of a required resolution."),"\n",l.createElement(t.p,null,"Third step is to link the RHI texture reference from the step #1 with UTexture2D object from the step #2. It is done on the render thread by calling ",l.createElement(t.em,null,"RHIUpdateTextureReference"),"."),"\n",l.createElement(t.p,null,"Now it is high time to ask why calling ",l.createElement(t.em,null,"RHIAsyncCreateTexture2D")," works in the first place? Turns out it is related to the support of a concurrent resource creation by OS graphics driver. Fortunately the use of a Direct3D 11 device (ID3D11Device) is thread-safe. And that is what vanilla Unreal Engine 4 uses. Eureka! If one wants to find out more information then they should search for both ",l.createElement(t.em,null,"D3D11_FEATURE_DATA_THREADING")," and ",l.createElement(t.em,null,"GRHISupportsAsyncTextureCreation")," in Unreal codebase."),"\n",l.createElement(t.p,null,"Full implementation of asynchronous texture creation is below:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-cpp"},'const int32 TextureSizeX = 1024;\nconst int32 TextureSizeY = 1024;\nEPixelFormat PixelFormat = EPixelFormat::PF_B8G8R8A8;\nconst int32 NumMips = 1;\n\n// Mip0Data\nconst int32 Mip0Size = TextureSizeX * TextureSizeY * GPixelFormats[PixelFormat].BlockBytes;\n\nTArray<uint8> Mip0Data;\nMip0Data.SetNum(Mip0Size);\n\n// Fill Mip0Data;\n// below "green" mip0 is constructed in a very bruteforce way\nfor (int32 Index = 0; Index < Mip0Size; Index += 4)\n{\n\tMip0Data[Index] = 0;\n\tMip0Data[Index + 1] = 255;\n\tMip0Data[Index + 2] = 0;\n\tMip0Data[Index + 3] = 255;\n}\n\n// make sure UTexture2D created on the game thread\n// game thread task should be spawned in case this code is being executed on the separated thread\ncheck (IsInGameThread());\n\n// Create transient texture\nUTexture2D* NewTexture = NewObject<UTexture2D>(\n\tGetTransientPackage(),\n\tMakeUniqueObjectName(GetTransientPackage(), UTexture2D::StaticClass(), *BaseFilename),\n\tRF_Transient\n);\ncheck(IsValid(NewTexture));\n\n// never link the texture to Unreal streaming system\nNewTexture->NeverStream = true;\n\n{\n\t// allocate dummy mipmap of 1x1 size\n\tNewTexture->PlatformData = new FTexturePlatformData();\n\tNewTexture->PlatformData->SizeX = 1;\n\tNewTexture->PlatformData->SizeY = 1;\n\tNewTexture->PlatformData->PixelFormat = PixelFormat;\n\n\tFTexture2DMipMap* Mip = new FTexture2DMipMap();\n\tNewTexture->PlatformData->Mips.Add(Mip);\n\tMip->SizeX = 1;\n\tMip->SizeY = 1;\n\n\t// GPixelFormats contains meta information for each pixel format\n\tconst uint32 MipBytes = Mip->SizeX * Mip->SizeY * GPixelFormats[PixelFormat].BlockBytes;\n\t{\n\t\tMip->BulkData.Lock(LOCK_READ_WRITE);\n\n\t\tvoid* TextureData = Mip->BulkData.Realloc(MipBytes);\n\n\t\tstatic TArray<uint8> DummyBytes;\n\t\tDummyBytes.SetNum(MipBytes);\n\n\t\tFMemory::Memcpy(TextureData, DummyBytes.GetData(), MipBytes);\n\n\t\tMip->BulkData.Unlock();\n\t}\n\n\t// construct texture\n\tNewTexture->UpdateResource();\n}\n\n// async create texture on the separate thread\nFTexture2DRHIRef RHITexture2D;\n\nAsync(\n\tEAsyncExecution::Thread,\n\t[&RHITexture2D, TextureSizeX, TextureSizeY, PixelFormat, NumMips, Mip0Data]\n\t{\n\t\tRHITexture2D = RHIAsyncCreateTexture2D(\n\t\t\tTextureSizeX, TextureSizeY,\n\t\t\tPixelFormat,\n\t\t\tNumMips,\n\t\t\tTexCreate_ShaderResource, Mip0Data.GetData(), NumMips\n\t\t);\n\t}\n).Wait();\n\n// link RHI texture to UTexture2D\nENQUEUE_RENDER_COMMAND(UpdateTextureReference)(\n    [NewTexture, RHITexture2D](FRHICommandListImmediate& RHICmdList)\n    {\n        RHIUpdateTextureReference(NewTexture->TextureReference.TextureReferenceRHI, RHITexture2D);\n\t\tNewTexture->RefreshSamplerStates();\n    }\n);\n\n// now the texture is ready and can be used for shading/sampling/etc.\n\n')),"\n",l.createElement(t.p,null,"Note: the above code has to be modified depending on the thread where one wants to construct textures."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Conclusion")),"\n",l.createElement(t.p,null,"Overall this approach works well with the high resolution textures and also gives a great flexibility in terms of what and when the texture related objects should be created. For example, generating texture mips on the background thread and then uploading them to GPU via ",l.createElement(t.em,null,"RHICopySharedMips")," is one of such examples. This approach is used in author's Unreal plugin called ",l.createElement(t.a,{href:"https://www.unrealengine.com/marketplace/en-US/product/runtime-image-loader"},l.createElement(t.strong,null,"RuntimeImageLoader")),", which is available on Unreal Marketplace!"),"\n",l.createElement(t.p,null,"The same approach can be applied to asynchronously create geometry buffers. Have fun!"))}var i,u=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?l.createElement(t,e,l.createElement(o,e)):o(e)},s=n(4810),c=n(2071),m=n(9935),p=n(7528),d=n(5765),h=n(1392);const x=(0,n(2568).DU)(i||(i=(0,a.A)(["\n  ","  \n  \n  pre code {\n    margin: 0;\n    padding: 0;\n    white-space: pre;\n    border: none;\n    background: transparent;\n  }\n  \n  .highlight pre {\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre {\n    margin-top: -15px;\n    margin-bottom: 5px;\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre code, pre tt {\n    background-color: transparent;\n    border: none;\n  }\n\n"])),(()=>null));function T(e){let{location:t,data:n,pageContext:a,children:o}=e;const i=n.site.siteMetadata.title,{previous:u,next:T}=a,g=n.mdx,f={shortname:n.site.siteMetadata.disqusID,config:{identifier:g.frontmatter.title,siteTitle:i}};return l.createElement(m.A,null,l.createElement(s.N_,{to:"/"},l.createElement("h3",{style:{margin:0,marginBottom:(0,d.di)(2)}},"Blog")),l.createElement(c.A,{location:t,title:i},l.createElement(p.A,{title:g.frontmatter.title,description:g.frontmatter.description,keywords:["blog","unreal engine"]}),l.createElement("h4",{style:{marginBottom:7,marginTop:0}},l.createElement("i",null,g.frontmatter.title)),l.createElement("p",{style:{...(0,d.hs)(-.2),display:"block",marginBottom:(0,d.di)(1/3),marginTop:0}},g.frontmatter.date),l.createElement(x),l.createElement(r.xA,null,o),l.createElement("hr",{style:{marginBottom:(0,d.di)(1)}}),l.createElement("div",null,l.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0,marginLeft:0}},l.createElement("li",null,u&&l.createElement(s.N_,{to:u.frontmatter.slug,rel:"prev"},"← ",l.createElement("i",null,u.frontmatter.title))),l.createElement("li",null,T&&l.createElement(s.N_,{to:T.frontmatter.slug,rel:"next"},l.createElement("i",null,T.frontmatter.title)," →")))),l.createElement(h.Mq,f)))}function g(e){return l.createElement(T,e,l.createElement(u,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-home-runner-work-raian-github-io-raian-github-io-content-blog-efficient-construction-of-textures-index-mdx-7b86174fb2f740748bf6.js.map