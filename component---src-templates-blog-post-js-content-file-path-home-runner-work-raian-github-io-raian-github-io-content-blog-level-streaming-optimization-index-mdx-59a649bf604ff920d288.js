"use strict";(self.webpackChunkpetr_leontev_tech_blog=self.webpackChunkpetr_leontev_tech_blog||[]).push([[884],{5312:function(e,t,n){n.r(t),n.d(t,{default:function(){return v}});var l=n(1880),r=n(1151),a=n(7294);function o(e){const t=Object.assign({p:"p",strong:"strong",em:"em",pre:"pre",code:"code",a:"a"},(0,r.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.p,null,"Unreal Engine 4 Level Streaming is very useful tool if you want to give yourself a freedom while creating an environment. Of course, that is not true in general and also comes with cost. Sometimes that cost is just too high and chances are it will kill your project."),"\n",a.createElement(t.p,null,"However, that is not an optimistic way of thinking. You can still do a ton of optimizations or, lets call them correctly, some streaming tweaks to save the day. Lets dive in."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.UseBackgroundLevelStreaming")),"\n",a.createElement(t.p,null,"Open ",a.createElement(t.em,null,"LevelStreaming.cpp")," and find the function ",a.createElement(t.em,null,"UpdateStreamingState")," and the following lines:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},"bool bBlockOnLoad = (bShouldBlockOnLoad || ShouldBeAlwaysLoaded());\n//...\nbBlockOnLoad |= (!GUseBackgroundLevelStreaming || !World->IsGameWorld());\n")),"\n",a.createElement(t.p,null,a.createElement(t.em,null,"bShouldBlockOnLoad")," and ",a.createElement(t.em,null,"ShouldBeAlwaysLoaded()")," are traits of LevelStreaming object that control whether we have to block this thread while loading the level or not (first trait can be changed via World Composition level settings)."),"\n",a.createElement(t.p,null,a.createElement(t.em,null,"bBlockOnLoad")," is only true (i.e. we block thread on level load) when world is not any kind of game world and we do not use ",a.createElement(t.em,null,"s.UseBackgroundLevelStreaming"),"."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.GLevelStreamingComponentsRegistrationGranularity")),"\n",a.createElement(t.p,null,"Open ",a.createElement(t.em,null,"World.cpp")," and find the function ",a.createElement(t.em,null,"AddToWorld"),". Documentation clearly states that this function associates the passed in level with the world. Most importantly, the work to make the level visible is spread across several frames and this function has to be called till it returns true for the level to be visible/associated with the world and no longer be in a limbo state."),"\n",a.createElement(t.p,null,"But which kind of work will be spread across several frames?"),"\n",a.createElement(t.p,null,"Lets look at the following piece of code from ",a.createElement(t.em,null,"AddToWorld"),":"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},'int32 NumComponentsToUpdate = GLevelStreamingComponentsRegistrationGranularity;\ndo\n{\n    Level->IncrementalUpdateComponents( (!IsGameWorld() || IsRunningCommandlet()) ? 0 : NumComponentsToUpdate, bRerunConstructionScript );\n}\nwhile( !Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded( TEXT("updating components"), StartTime, Level, TimeLimit )));\n\n// We are done once all components are attached.\nLevel->bAlreadyUpdatedComponents = Level->bAreComponentsCurrentlyRegistered;\nbExecuteNextStep = Level->bAreComponentsCurrentlyRegistered && (!bConsiderTimeLimit || !IsTimeLimitExceeded(TEXT("updating components"), StartTime, Level, TimeLimit));\n')),"\n",a.createElement(t.p,null,"As we can see ",a.createElement(t.em,null,"s.GLevelStreamingComponentsRegistrationGranularity")," is just a number of components to update during execution of ",a.createElement(t.em,null,"AddToWorld"),". So, each time we call ",a.createElement(t.em,null,"AddToWorld")," the execution will be stopped as soon as either time limit is exceeded or all level components have been registered."),"\n",a.createElement(t.p,null,"Besides that, there is the condition ",a.createElement(t.em,null,"(!IsGameWorld() || IsRunningCommandlet())")," that says we are only going to register NumComponentsToUpdate components if we are not in commandlet mode and current world is the game world."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.LevelStreamingActorsUpdateTimeLimit")," and ",a.createElement(t.strong,null,"s.PriorityLevelStreamingActorsUpdateExtraTime")),"\n",a.createElement(t.p,null,"As you could notice above there is ",a.createElement(t.em,null,"TimeLimit")," term and, what is really important, it is measured in seconds."),"\n",a.createElement(t.p,null,"By default ",a.createElement(t.em,null,"TimeLimit")," for AddToWorld execution is ",a.createElement(t.em,null,"LevelStreamingActorsUpdateTimeLimit")," value. However, if high priority load has to happen (which is the topic for separate article) then we just add value of ",a.createElement(t.em,null,"PriorityLevelStreamingActorsUpdateExtraTime")," and as result:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},"TimeLimit = LevelStreamingActorsUpdateTimeLimit [+ PriorityLevelStreamingActorsUpdateExtraTime if HighPriorityLoad]\n")),"\n",a.createElement(t.p,null,a.createElement(t.em,null,"TimeLimit")," is checked after almost each step in ",a.createElement(t.em,null,"AddToWorld")," function:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},"* Applying level transform to level actors (FLevelUtils::ApplyLevelTransform)\n* Applying world offset to level (ULevel::ApplyWorldOffset)\n* Updating level components (ULevel::IncrementalUpdateComponents)\n* Initializing level actors (ULevel::InitializeNetworkActors)\n* Routing various initialization functions (ULevel::RouteActorInitialize())\n* Sorting actor list (ULevel::SortActorList)\n")),"\n",a.createElement(t.p,null,"If you increase the value of ",a.createElement(t.em,null,"s.LevelStreamingActorsUpdateTimeLimit")," too much then you will see a lot of hitches if your levels are content heavy. However, if value is too small then level won't be loaded in time (before player sees it) and it can cause different set of problems (for example, player will fall down under the world) so tweak this value carefully."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.LevelStreamingComponentsUnregistrationGranularity")),"\n",a.createElement(t.p,null,"This option is very similar to ",a.createElement(t.em,null,"s.GLevelStreamingComponentsRegistrationGranularity")," except that it is used in ",a.createElement(t.em,null,"RemoveFromWorld")," (also in World.cpp)."),"\n",a.createElement(t.p,null,"Look at the code below:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},'int32 NumComponentsToUnregister = GLevelStreamingComponentsUnregistrationGranularity;\ndo\n{\n    if (Level->IncrementalUnregisterComponents(NumComponentsToUnregister))\n    {\n        // We\'re done, so the level can be removed\n        CurrentLevelPendingInvisibility = nullptr;\n        bFinishRemovingLevel = true;\n        break;\n    }\n} while (!IsTimeLimitExceeded(TEXT("unregistering components"), StartTime, Level, GLevelStreamingUnregisterComponentsTimeLimit));\n')),"\n",a.createElement(t.p,null,"Take note that unregistration procedure is timesliced only when level does not block thread while loading and corresponding world is a game world. This is controlled by ",a.createElement(t.em,null,"RemoveFromWorld")," second input parameter, ",a.createElement(t.em,null,"bAllowIncrementalRemoval"),"."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.GLevelStreamingForceGCAfterLevelStreamedOut")),"\n",a.createElement(t.p,null,"Forced garbage collection can easily make your game hitch because it does a lot of stuff under the hood (from checking references to freeing memory if needed)."),"\n",a.createElement(t.p,null,a.createElement(t.em,null,"GLevelStreamingForceGCAfterLevelStreamedOut")," is used in two separate contexts. Lets look at the first one from the function ",a.createElement(t.em,null,"UpdateLevelStreaming")," in ",a.createElement(t.em,null,"World.cpp"),":"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},"// In case more levels has been requested to unload, force GC on next tick \nif (GLevelStreamingForceGCAfterLevelStreamedOut != 0)\n{\n    if (NumLevelsPendingPurge < FLevelStreamingGCHelper::GetNumLevelsPendingPurge())\n    {\n        GEngine->ForceGarbageCollection(true); \n    }\n}\n")),"\n",a.createElement(t.p,null,"Overall, ",a.createElement(t.em,null,"UpdateLevelStreaming")," can be called from a lot of different places in UE4 code. If you profile your game and see GC hitches when levels are unloaded then chances are that you are experiencing hitches caused by forced garbage collection."),"\n",a.createElement(t.p,null,a.createElement(t.strong,null,"s.GLevelStreamingContinuouslyIncrementalGCWhileLevelsPendingPurge")),"\n",a.createElement(t.p,null,"Find the function ",a.createElement(t.em,null,"UpdateStreamingState")," in ",a.createElement(t.em,null,"LevelStreaming.cpp")," and look the following piece of code in it:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-cpp"},"if (GLevelStreamingContinuouslyIncrementalGCWhileLevelsPendingPurge)\n{\n    // Figure out whether there are any levels we haven't collected garbage yet.\n    const bool bAreLevelsPendingPurge = FLevelStreamingGCHelper::GetNumLevelsPendingPurge() > 0;\n\n    // Request a 'soft' GC if there are levels pending purge and there are levels to be loaded. In the case of a blocking\n    // load this is going to guarantee GC firing first thing afterwards and otherwise it is going to sneak in right before\n    // kicking off the async load.\n    if (bAreLevelsPendingPurge)\n    {\n        GEngine->ForceGarbageCollection(false);\n    }\n}\n")),"\n",a.createElement(t.p,null,"As you can see the only difference to ",a.createElement(t.em,null,"s.GLevelStreamingForceGCAfterLevelStreamedOut")," is that we pass ",a.createElement(t.em,null,"false")," as an argument to ForceGarbageCollection. That means garbage collection won't be forced."),"\n",a.createElement(t.p,null,"All mentioned console variables above could be a good starting point to optimize level streaming and gargage collection behaviour of your game. ",a.createElement(t.strong,null,"However, note that there are no silver bullets for each and every case so you should always profile your game before doing any optimization.")),"\n",a.createElement(t.p,null,"Unreal Engine 4 website has great ",a.createElement(t.a,{href:"https://docs.unrealengine.com/en-US/Engine/Performance/index.html"},a.createElement(t.strong,null,"documentation"))," about what exactly you should profile in your game so check it out!"),"\n",a.createElement(t.p,null,"P.S. Besides all that there is a way to fix your PhysX tree rebuild rate: the number of frames it takes to rebuild the PhysX scene query AABB tree, the bigger the number, the smaller fetchResults takes per frame, but the more the tree deteriorates until a new tree is built (according to official documentation). Use either config variable ",a.createElement(t.em,null,"PhysXTreeRebuildRate")," in Project Settings or console command ",a.createElement(t.em,null,"p.PhysXTreeRebuildRate number_of_frames"),"."),"\n",a.createElement(t.p,null,"Enjoy!"))}var i,m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.ah)(),e.components);return t?a.createElement(t,e,a.createElement(o,e)):o(e)},c=n(1883),s=n(9565),u=n(1212),d=n(9357),p=n(9175),g=n(3944);const h=(0,n(2788).vJ)(i||(i=(0,l.Z)(["\n  ","  \n  \n  pre code {\n    margin: 0;\n    padding: 0;\n    white-space: pre;\n    border: none;\n    background: transparent;\n  }\n  \n  .highlight pre {\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre {\n    margin-top: -15px;\n    margin-bottom: 5px;\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre code, pre tt {\n    background-color: transparent;\n    border: none;\n  }\n\n"])),(()=>null));function f(e){let{location:t,data:n,pageContext:l,children:o}=e;const i=n.site.siteMetadata.title,{previous:m,next:f}=l,v=n.mdx,E={shortname:n.site.siteMetadata.disqusID,config:{identifier:v.frontmatter.title,siteTitle:i}};return a.createElement(u.Z,null,a.createElement(c.rU,{to:"/"},a.createElement("h3",{style:{margin:0,marginBottom:(0,p.qZ)(2)}},"Blog")),a.createElement(s.Z,{location:t,title:i},a.createElement(d.Z,{title:v.frontmatter.title,description:v.frontmatter.description,keywords:["blog","unreal engine"]}),a.createElement("h4",{style:{marginBottom:7,marginTop:0}},a.createElement("i",null,v.frontmatter.title)),a.createElement("p",{style:{...(0,p.bA)(-.2),display:"block",marginBottom:(0,p.qZ)(1/3),marginTop:0}},v.frontmatter.date),a.createElement(h),a.createElement(r.Zo,null,o),a.createElement("hr",{style:{marginBottom:(0,p.qZ)(1)}}),a.createElement("div",null,a.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0,marginLeft:0}},a.createElement("li",null,m&&a.createElement(c.rU,{to:m.frontmatter.slug,rel:"prev"},"← ",a.createElement("i",null,m.frontmatter.title))),a.createElement("li",null,f&&a.createElement(c.rU,{to:f.frontmatter.slug,rel:"next"},a.createElement("i",null,f.frontmatter.title)," →")))),a.createElement(g.qw,E)))}function v(e){return a.createElement(f,e,a.createElement(m,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-home-runner-work-raian-github-io-raian-github-io-content-blog-level-streaming-optimization-index-mdx-59a649bf604ff920d288.js.map