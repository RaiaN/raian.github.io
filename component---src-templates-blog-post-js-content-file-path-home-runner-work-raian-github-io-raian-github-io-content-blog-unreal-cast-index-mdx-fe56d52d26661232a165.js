"use strict";(self.webpackChunkpetr_leontev_tech_blog=self.webpackChunkpetr_leontev_tech_blog||[]).push([[131],{2456:function(e,t,n){n.r(t),n.d(t,{default:function(){return T}});var a=n(5276),l=n(8453),r=n(6540);function s(e){const t=Object.assign({p:"p",strong:"strong",code:"code",a:"a",pre:"pre",em:"em"},(0,l.RP)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"Unreal Engine C++ ",r.createElement(t.strong,null,r.createElement(t.code,null,"Cast<T>(SomeObject)"))," allows to dynamically cast an object type-safely. But what is difference between ",r.createElement(t.code,null,"Cast<T>")," and ",r.createElement(t.code,null,"dynamic_cast<T*>"),"? Lets figure that out!"),"\n",r.createElement(t.p,null,"Unreal Engine C++ provides a built-in support for ",r.createElement(t.a,{href:"https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection"},r.createElement(t.strong,null,"reflection system"))," that provides the way to perform type-safe up- and down-casts without a need for ",r.createElement(t.code,null,"dynamic_cast<T*>"),". Lets look at the function ",r.createElement(t.code,null,"Cast<T>"),":"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"template <typename To, typename From>\nFORCEINLINE To* Cast(From* Src)\n{\n\treturn TCastImpl<From, To>::DoCast(Src);\n}\n")),"\n",r.createElement(t.p,null,r.createElement(t.em,null,"Cast")," function simply uses some template structure called ",r.createElement(t.em,null,"TCastImpl")," to convert the pointer of ",r.createElement(t.em,null,"From")," class to the pointer of ",r.createElement(t.em,null,"To")," class. Indeed, ",r.createElement(t.em,null,"TCastImpl")," is where all the magic happens."),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"template <typename From, typename To, ECastType CastType = TGetCastType<From, To>::Value>\nstruct TCastImpl\n{\n\t// This is the cast flags implementation\n\tFORCEINLINE static To* DoCast( UObject* Src )\n\t{\n\t\treturn Src && Src->GetClass()->HasAnyCastFlag(TCastFlags<To>::Value) ? (To*)Src : nullptr;\n\t}\n\n\tFORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src )\n\t{\n\t\treturn (To*)Src;\n\t}\n};\n")),"\n",r.createElement(t.p,null,"Given the valid pointer of ",r.createElement(t.em,null,"From")," class ",r.createElement(t.em,null,"DoCast")," uses C-style cast to convert it to the pointer of ",r.createElement(t.em,null,"To")," class, otherwise nullptr is returned (note that ",r.createElement(t.code,null,"dynamic_cast<T>")," is neved considered when using a C-style cast). This way both const and non-const pointers are handled correctly since C-style casts tries ",r.createElement(t.code,null,"const_cast")," first and only then ",r.createElement(t.code,null,"static_cast"),". So far, so good."),"\n",r.createElement(t.p,null,"There are several questions about ",r.createElement(t.em,null,"DoCast")," implementation. The first is how efficient ",r.createElement(t.em,null,"HasAnyCastFlag()")," function? It turns out that this function simply checks bitmask. Also notice that ",r.createElement(t.em,null,"FORCEINLINE")," is used (which is actually ",r.createElement(t.a,{href:"https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?redirectedfrom=MSDN&view=vs-2019"},r.createElement(t.em,null,"__forceinline"))," keyword that is supported by MSVC) to potentially remove the function call cost."),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"FORCEINLINE bool HasAnyCastFlag(EClassCastFlags FlagToCheck) const\n{\n    return (ClassCastFlags&FlagToCheck) != 0;\n}\n")),"\n",r.createElement(t.p,null,"Also, it is important to remember that the ",r.createElement(t.em,null,"Cast")," function should not be called too often. Ideally, the game code should not call ",r.createElement(t.em,null,"Cast")," function at all!"),"\n",r.createElement(t.p,null,"The second question is related to C-style cast. Will ",r.createElement(t.em,null,"reinterpret_cast")," be used in some cases? The answer is not because that is where Unreal ",r.createElement(t.em,null,"reflection system")," comes into play. What it does is simply stores an additional information about the class in its ",r.createElement(t.em,null,"CDO (Class Default Object)"),". More specifically, it is either corresponding ",r.createElement(t.em,null,"UStruct")," object or ",r.createElement(t.em,null,"ClassCastFlags")," or both. Using this reflection information in runtime one can determine whether two classes belong to the same hierarchy and if they are not then nullptr is returned."),"\n",r.createElement(t.p,null,"Now lets return to the structure ",r.createElement(t.em,null,"TCastImpl"),". It turns out that ",r.createElement(t.em,null,"TCastImpl::DoCast")," function above won't be called in the default configuration of UE4 C++ module. Why? This is all due to how the template structure ",r.createElement(t.em,null,"TGetCastType")," works (below)."),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"template <typename From, typename To, bool bFromInterface = TIsIInterface<From>::Value, bool bToInterface = TIsIInterface<To>::Value, EClassCastFlags CastClass = TCastFlags<To>::Value>\nstruct TGetCastType\n{\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\n\tstatic const ECastType Value = ECastType::UObjectToUObject;\n#else\n\tstatic const ECastType Value = ECastType::FromCastFlags;\n#endif\n};\n\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, false, CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToUObject;     };\ntemplate <typename From, typename To                           > struct TGetCastType<From, To, false, true , CASTCLASS_None> { static const ECastType Value = ECastType::UObjectToInterface;   };\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  false, CastClass     > { static const ECastType Value = ECastType::InterfaceToUObject;   };\ntemplate <typename From, typename To, EClassCastFlags CastClass> struct TGetCastType<From, To, true,  true , CastClass     > { static const ECastType Value = ECastType::InterfaceToInterface; };\n")),"\n",r.createElement(t.p,null,"The third and the forth template arguments of ",r.createElement(t.em,null,"TGetCastType")," are checked for an interface type. This way one of four ",r.createElement(t.em,null,"TGetCastType")," specializations above will be chosen. After that the specialization of ",r.createElement(t.em,null,"TCastImpl")," structure will be selected using ",r.createElement(t.em,null,"ECastType")," value to perform the cast itself (",r.createElement(t.em,null,"UObject to UObject"),", ",r.createElement(t.em,null,"UObject to Interface")," and so on)."),"\n",r.createElement(t.p,null,"Lets look at the one of ",r.createElement(t.em,null,"TCastImpl")," specializations that handles ",r.createElement(t.em,null,"UObject to UObject")," cast (other ",r.createElement(t.em,null,"TCastImpl")," specializations are quite similar):"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"template <typename From, typename To>\nstruct TCastImpl<From, To, ECastType::UObjectToUObject>\n{\n\tFORCEINLINE static To* DoCast( UObject* Src )\n\t{\n\t\treturn Src && Src->IsA<To>() ? (To*)Src : nullptr;\n\t}\n\n\tFORCEINLINE static To* DoCastCheckedWithoutTypeCheck( UObject* Src )\n\t{\n\t\treturn (To*)Src;\n\t}\n};\n")),"\n",r.createElement(t.p,null,r.createElement(t.em,null,"DoCast()")," calls ",r.createElement(t.em,null,"IsA()")," function to determine whether passed object is of the specified type. If that is true then C-style cast is applied."),"\n",r.createElement(t.p,null,"What is the performance cost of ",r.createElement(t.em,null,"IsA()")," function call in the default configuration of UE4 C++ module? It turns out that the performance heavy part of ",r.createElement(t.em,null,"IsA()")," function is the call to ",r.createElement(t.em,null,"IsChildOf()")," function that has two quite different implementations."),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"\t/** Returns true if this struct either is SomeBase, or is a child of SomeBase. This will not crash on null structs */\n#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK || USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_OUTERWALK\n\tbool IsChildOf( const UStruct* SomeBase ) const;\n#else\n\tbool IsChildOf(const UStruct* SomeBase) const\n\t{\n\t\treturn (SomeBase ? IsChildOfUsingStructArray(*SomeBase) : false);\n\t}\n#endif\n")),"\n",r.createElement(t.p,null,"When ",r.createElement(t.em,null,"UE_EDITOR")," = 1 the preprocessor directive ",r.createElement(t.em,null,"USTRUCT_FAST_ISCHILDOF_IMPL = USTRUCT_ISCHILDOF_OUTERWALK")," and that means the following implementation of ",r.createElement(t.em,null,"IsChildOf")," function is going to be used:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},'#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK || USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_OUTERWALK\nbool UStruct::IsChildOf( const UStruct* SomeBase ) const\n{\n\tif (SomeBase == nullptr)\n\t{\n\t\treturn false;\n\t}\n\n\tbool bOldResult = false;\n\tfor ( const UStruct* TempStruct=this; TempStruct; TempStruct=TempStruct->GetSuperStruct() )\n\t{\n\t\tif ( TempStruct == SomeBase )\n\t\t{\n\t\t\tbOldResult = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\n\tconst bool bNewResult = IsChildOfUsingStructArray(*SomeBase);\n#endif\n\n#if USTRUCT_FAST_ISCHILDOF_COMPARE_WITH_OUTERWALK\n\tensureMsgf(bOldResult == bNewResult, TEXT("New cast code failed"));\n#endif\n\n\treturn bOldResult;\n}\n#endif\n')),"\n",r.createElement(t.p,null,"The most important part here is the inner ",r.createElement(t.em,null,"for")," loop that tries to find a pair of equal reflection structs between a given class and a passed one. If such a pair is found then one class is a child of another. Runtime cost of such ",r.createElement(t.em,null,"IsChildOf")," function is equal to the depth of the inheritance tree, ",r.createElement(t.em,null,"O(Depth(InheritanceTree))"),"."),"\n",r.createElement(t.p,null,"When ",r.createElement(t.em,null,"UE_EDITOR")," = 1 the preprocessor directive ",r.createElement(t.em,null,"USTRUCT_FAST_ISCHILDOF_IMPL = USTRUCT_ISCHILDOF_STRUCTARRAY")," and that means the following implementation of ",r.createElement(t.em,null,"IsChildOf")," function is going to be used:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"bool IsChildOf(const UStruct* SomeBase) const\n{\n    return (SomeBase ? IsChildOfUsingStructArray(*SomeBase) : false);\n}\n\n#if USTRUCT_FAST_ISCHILDOF_IMPL == USTRUCT_ISCHILDOF_STRUCTARRAY\nclass FStructBaseChain\n{\nprotected:\n\tCOREUOBJECT_API FStructBaseChain();\n\tCOREUOBJECT_API ~FStructBaseChain();\n\n\t// Non-copyable\n\tFStructBaseChain(const FStructBaseChain&) = delete;\n\tFStructBaseChain& operator=(const FStructBaseChain&) = delete;\n\n\tCOREUOBJECT_API void ReinitializeBaseChainArray();\n\n    // this is O(1) implementation of IsChildOf\n\tFORCEINLINE bool IsChildOfUsingStructArray(const FStructBaseChain& Parent) const\n\t{\n\t\tint32 NumParentStructBasesInChainMinusOne = Parent.NumStructBasesInChainMinusOne;\n\t\treturn NumParentStructBasesInChainMinusOne <= NumStructBasesInChainMinusOne && StructBaseChainArray[NumParentStructBasesInChainMinusOne] == &Parent;\n\t}\n\nprivate:\n\tFStructBaseChain** StructBaseChainArray;\n\tint32 NumStructBasesInChainMinusOne;\n\n\tfriend class UStruct;\n};\n#endif\n")),"\n",r.createElement(t.p,null,"The function ",r.createElement(t.em,null,"IsChildOfUsingStructArray")," uses ",r.createElement(t.em,null,"StructBaseChainArray")," array as a storage for reflection data or structs of the class to speed up the checking algorithm."),"\n",r.createElement(t.p,null,"How ",r.createElement(t.code,null,"Cast<T>")," can support both up- and down-casts? The reason is that pointers of different classes can point to the same object but that does not change their reflection data or structs (and indeed the content of ",r.createElement(t.em,null,"StructBaseChainArray"),") so ",r.createElement(t.em,null,"IsA")," will always find a pair of equal reflection structs given both classes belong to the same class hierarchy."),"\n",r.createElement(t.p,null,"This leads to the conclusion that ",r.createElement(t.code,null,"Cast<T> runtime cost")," is:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"- Linear,   O(Depth(InheritanceTree)), in the editor environment     (UE_EDITOR = 1).\n- Constant, O(1),                      in the non-editor environment (UE_EDITOR = 0).\n")),"\n",r.createElement(t.p,null,"To slightly reduce ",r.createElement(t.code,null,"Cast<T>")," runtime cost there is the function ",r.createElement(t.code,null,"ExactCast<T>"),":"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"template< class T >\nFORCEINLINE T* ExactCast( UObject* Src )\n{\n\treturn Src && (Src->GetClass() == T::StaticClass()) ? (T*)Src : nullptr;\n}\n")),"\n",r.createElement(t.p,null,"Both ",r.createElement(t.em,null,"GetClass()")," and ",r.createElement(t.em,null,"StaticClass()")," calls are O(1) so ",r.createElement(t.em,null,"ExactCast")," is a good option when the type of a passed object is known beforehand. There is even a more efficient ",r.createElement(t.em,null,"CastChecked")," function, which is basically C-style cast in non-editor environment but it is not that quite safe though."),"\n",r.createElement(t.p,null,"Now, what is the point of using ",r.createElement(t.code,null,"Cast<T>")," if one can go for ",r.createElement(t.em,null,"static_cast")," to do exactly the same? The answer is type safety. ",r.createElement(t.strong,null,"If one mismatches the class types or change the inheritance tree ",r.createElement(t.code,null,"Cast<T>")," will return nullptr. ",r.createElement(t.em,null,"static_cast"),", in contrast, may perform cast and return some invalid pointer"),". Below is the example of such a behaviour:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"// APawn is the parent of ACharacter\nAPawn* NewPawn = NewObject<APawn>(GWorld);\n\nACharacter* StaticCastCharacter = static_cast<ACharacter*>(NewPawn);\nACharacter* UnrealCastCharacter = Cast<ACharacter>(NewPawn);\n")),"\n",r.createElement(t.p,null,r.createElement(t.code,null,"static_cast<ACharacter*>")," above will return a pointer to ",r.createElement(t.em,null,"ACharacter")," even though created object is of type ",r.createElement(t.em,null,"APawn"),". However, ",r.createElement(t.code,null,"Cast<ACharacter>")," will return ",r.createElement(t.em,null,"nullptr"),", which is much better."),"\n",r.createElement(t.p,null,"To close C++ casts topic, one may still use ",r.createElement(t.em,null,"dynamic_cast"),' in Unreal C++ but it is heavily "overridden" to use ',r.createElement(t.code,null,"Cast<T>")," function when possible (when casting from pointer to pointer or from rvalue to rvalue)."),"\n",r.createElement(t.p,null,"To sum up, key things about ",r.createElement(t.code,null,"Cast<T>")," in Unreal C++ are listed below:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-cpp"},"- Cast<T> has to be used for *UObjects* due to type safety; it will return *nullptr* in case of a failure in comparison with *static_cast*.\n- Cast<T> runtime cost is *O(1) or constant* in non-editor environment and *O(Depth(InheritanceTree))* in editor environment.\n- Cast<T> does not use *dynamic_cast*.\n")),"\n",r.createElement(t.p,null,"Enjoy!"))}var c,o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.RP)(),e.components);return t?r.createElement(t,e,r.createElement(s,e)):s(e)},i=n(4810),m=n(2071),u=n(9935),p=n(7528),h=n(5765),C=n(1392);const E=(0,n(2568).DU)(c||(c=(0,a.A)(["\n  ","  \n  \n  pre code {\n    margin: 0;\n    padding: 0;\n    white-space: pre;\n    border: none;\n    background: transparent;\n  }\n  \n  .highlight pre {\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre {\n    margin-top: -15px;\n    margin-bottom: 5px;\n    background-color: #f8f8f8;\n    border: 1px solid #cccccc;\n    font-size: 13px;\n    line-height: 19px;\n    overflow: auto;\n    padding: 6px 10px;\n    border-radius: 3px;\n  }\n  \n  pre code, pre tt {\n    background-color: transparent;\n    border: none;\n  }\n\n"])),(()=>null));function d(e){let{location:t,data:n,pageContext:a,children:s}=e;const c=n.site.siteMetadata.title,{previous:o,next:d}=a,T=n.mdx,f={shortname:n.site.siteMetadata.disqusID,config:{identifier:T.frontmatter.title,siteTitle:c}};return r.createElement(u.A,null,r.createElement(i.N_,{to:"/"},r.createElement("h3",{style:{margin:0,marginBottom:(0,h.di)(2)}},"Blog")),r.createElement(m.A,{location:t,title:c},r.createElement(p.A,{title:T.frontmatter.title,description:T.frontmatter.description,keywords:["blog","unreal engine"]}),r.createElement("h4",{style:{marginBottom:7,marginTop:0}},r.createElement("i",null,T.frontmatter.title)),r.createElement("p",{style:{...(0,h.hs)(-.2),display:"block",marginBottom:(0,h.di)(1/3),marginTop:0}},T.frontmatter.date),r.createElement(E),r.createElement(l.xA,null,s),r.createElement("hr",{style:{marginBottom:(0,h.di)(1)}}),r.createElement("div",null,r.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0,marginLeft:0}},r.createElement("li",null,o&&r.createElement(i.N_,{to:o.frontmatter.slug,rel:"prev"},"← ",r.createElement("i",null,o.frontmatter.title))),r.createElement("li",null,d&&r.createElement(i.N_,{to:d.frontmatter.slug,rel:"next"},r.createElement("i",null,d.frontmatter.title)," →")))),r.createElement(C.Mq,f)))}function T(e){return r.createElement(d,e,r.createElement(o,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-home-runner-work-raian-github-io-raian-github-io-content-blog-unreal-cast-index-mdx-fe56d52d26661232a165.js.map